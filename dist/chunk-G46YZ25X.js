var a=class{_value;subscribers;dependents=new Set;constructor(e){this._value=e}get value(){return n.current&&(this.dependents.add(n.current),n.current.dependencies.add(this)),this._value}set value(e){this._value!==e&&(this._value=e,Array.from(this.dependents).forEach(s=>s.invalidate()),this.subscribers?.forEach(s=>s(e)))}peek(){return this._value}get(){return this.value}set(e){this.value=e}update(e){this.set(e(this._value))}subscribe(e){return e(this._value),this.subscribers||(this.subscribers=new Set),this.subscribers.add(e),()=>{this.subscribers.delete(e)}}},n=class t{static lastId=0;id=t.lastId++;fn;dependencies=new Set;isRunning=!1;isCleaning=!1;onInnerCleanup=void 0;onInvalidate=null;parentComputation;childComputations=new Set;constructor(e,i=null){this.fn=e,this.parentComputation=i,this.run()}run(){if(!this.isRunning){this.cleanup(!1),t.stack.push(this),t.current=this;try{this.isRunning=!0;let e=this.fn();typeof e=="function"?this.onInnerCleanup=e:this.onInnerCleanup=void 0}finally{this.isRunning=!1,t.stack.pop(),t.current=t.stack[t.stack.length-1]||null}}}invalidate(){t.isBatching?t.pending.add(this):this.onInvalidate?this.onInvalidate():this.run()}cleanup(e=!0){this.isCleaning||(this.isCleaning=!0,Array.from(this.childComputations).forEach(i=>{i.cleanup()}),this.onInnerCleanup&&(this.onInnerCleanup(),this.onInnerCleanup=void 0),this.dependencies.forEach(i=>i.dependents.delete(this)),this.dependencies.clear(),this.parentComputation&&e&&this.parentComputation.childComputations.delete(this),this.isCleaning=!1)}static current=null;static stack=[];static isBatching=!1;static pending=new Set},r=class{signal;cleanup;constructor(e){this.signal=new a(void 0),this.cleanup=o(()=>{this.signal.value=e()})}get value(){return this.signal.value}peek(){return this.signal.peek()}get(){return this.signal.get()}subscribe(e){return this.signal.subscribe(e)}};function u(t){return new a(t)}function o(t){let e=n.current,i=new n(t,e);return e&&e.childComputations.add(i),()=>i.cleanup()}function l(t){return new r(t)}function c(t){let e=n.isBatching;n.isBatching=!0;try{t()}finally{if(n.isBatching=e,!n.isBatching){let i=Array.from(n.pending);n.pending.clear(),i.forEach(s=>s.run())}}}function p(t){return typeof t=="object"&&t!==null&&"get"in t&&"peek"in t&&"subscribe"in t}export{a,n as b,u as c,o as d,l as e,c as f,p as g};
